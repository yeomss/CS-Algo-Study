## 2.1 서버간 통신

**MSA가 나오게된 배경**

하나의 서비스 단위로 개발한다고 했을 때 

ex) 블로그, 카페, 메일 등의 기능들을 하나의 애플리케이션에 통합했다고 했을 때

애플리케이션을 유지보수 할 때마다 ‘사이트 작업 중입니다’라고 팻말 걸고 작업

→ 개발에 보수적이게 됨

→ 서비스 자체의 규모도 커져서 서비스 구동하는데 시간 오래 걸림

**MSA (Microservice Architecture)**

서비스 규모를 작게 나누어 구성한 아키텍처

단일 서비스 아키텍처 **vs** 마이크로 서비스 아키테처

단일 서버와 달리 Microservice Architecture의 경우 서버간 통신 필요

## 2.2 스프링 부트의 동작 방식

스프링에서 spring-boot-starter-web 모듈을 사용하면 기본적으로 tomcat 사용하는 **MVC 구조**를 기반으로 동작

- Servlet은 클라이언트의 요청을 처리하고 결과를 반환하는 자바 웹 프로그래밍 기술
    - Servlet은 Servlet Container에서 관리

- Servlet Container: Servlet Instance를 생성하고 관리하는 역할을 수행하는 주체
- 톰캣: WAS의 역할과 서블릿 컨테이너의 역할을 수행하는 컨테이너

- Servlet Container의 특징
    - 서블릿 객체를 생성, 초기화, 호출, 종료한느 생명주기 관리
    - 서블릿 객체는 싱글톤 패턴으로 관리
    - 멀티 스레딩을 지원

스프링에서는 DispatcherServlet이 서블릿 역할 수행

**DispatcherServlet 동작**

1. DispatcherServlet으로 요청 (HttpServletRequest)이 들어오면 DispatcherServlet은 핸들러 매핑 (handler Mapping)을 통해 요청 URI에 매핑된 핸들러를 탐색
2. 그리고 핸들러 어댑터 (HandlerAdapter)로 컨트롤러 호출
3. 핸들러 어댑터에 컨트롤러의 응답이 돌아오면 ModelAndView로 응답을 가공해 반환
4. 뷰 형식으로 리턴하는 컨트롤러를 사욯라 땐느 뷰 리졸버 (View Resolver)를 통해 뷰 (View)를 받아 리턴

```
핸들러 매핑: 요청 정보를 기준으로 어떤 컨트롤러를 사욯라지 선정하는 인터페이스
```

## 2.3 레이어트 아키텍처

애플리케이션의 컴포넌트를 유사 관심사를 기주능로 레이어로 묶어 수평적으로 구성한 구조를 의미

일반적으로 레이어드 아키텍처라고 하면 3계층 or 4계층 구성 (인프라 데이터 베이스) 레이어 추가 여부로 결정

**프레젠테이션 계층**

- 애플리케이션의 최상단 계층으로 클라이언트의 요청을 해석하고 응답하는 역할
- UI나 API를 제공

**비즈니스 계층**

- 애플리케이션을 제공하는 기능을 정의 세부작업을 수행하는 도메인 객체를 통해 업무를 위임하는 역할 수행
- DDD (Domain-Driven Design) 기반의 아키텍처에서는 비즈니스 로직에 도메인이 포함되기도 하고, 별도로 도메인 계층을 두기도 함

**데이터 접근 계층**

- 데이터베이스에 접근하는 일련의 작업을 수행

**레이어드 아키텍처 기반 설계 특징**

- 각 레이어는 가장 가까운 하위 레이어의 의존성을 주입
- 각 레이어는 관심사에 따라 묶여 있으며, 다른 레이어의 역할을 침범하지 않음
    - 각 컴포넌트의 역할이 명호가하므로 코드의 갇고성과 기능 구현에 유리
    - 코드의 확장성도 좋아짐
- 각 레이어가 독립적으로 작성되면 다른 레이어와의 의존성을 낮춰 단위 테스트에 용이

**스프링에서의 레이어드 아키텍처**

**프레젠테이션 계층**

- 상황에 따라 유저 인터페이스 (UI : User Interface) 계층이라고도 함
- 클라이언트와의 접점
- 클라이언트로부터 데이터와 함께 요청을 받고 처리 결과를 응답으로 전달하는 역할

**비즈니스 계층**

- 상황에 따라 서비스(Service) 계층이라고도 함
- 핵심 비즈니스 로직을 구현하는 영역
- 트랙잭션 처리나 유효성 검사 등의 작업 수행

**데이터 접근 계층**

- 상황에 따라 영속(Persistence) 계층이라고도 함
- 데이터베이스에 접근해야하는 작업 수행
- JPA or DAO 리포지토리 수행

## 2.4 디자인 패턴

Design Pattern : 소프트웨어를 설계할 때 자주 발생하는 문제들을 해결하기 위해 고안된 해결책

### 2.4.1 디자인 패턴의 종류

GoF 디자인 패턴 (Gang of Four) : 디자인 패턴을 구체화하고 체계화해서 분류한 4명의 인물

- 생성(Creational) 패턴
    - 객체 생성에 사용되는 패턴, 객체를 수정해도 호출부가 영향 받지 않도록 함
- 구조(Structural) 패턴
    - 객체를 조합해서 더 큰 구조를 만드는 패턴
- 행위(Behavioral) 패턴
    - 객체간의 알고리즘이나 책임 분배에 관한 패턴
    - 객체 하나로는 수행할 수 없는 작업을 여러 객체를 이용해 작업을 분배
    - 결합도 최소호를 고려할 필요가 있다.
    

### 2.4.2 생성 패턴

- 추상팩토리:
구체적인 클래스를 지정하지 않고 상황에 맞는 개체를 생성하기 위한 인터페이스를 제공하는 패턴
- 빌더
- 팩토리 메서드
- 프로토 타입
- **싱글톤**:
한 클래스마다 인스턴스를 하나만 생성해서 인스턴스가 하나임을 보장하고 어느 곳에서도 접근할 수 있게 제공하는 패턴

### 2.4.3 구조 패턴

- 어댑터
- 브리지
- 컴포지트
- 데코레이터
- 퍼사드
- 플라이웨이트
- 프락시

### 2.4.4 행위패턴

- 책임 연쇄
- 커맨드
- 인터프리터
- 이터레이터
- 미디에이터
- 메멘토
- 옵저버
- 스테이트
- 스트래티지
- 템플릿 메서드
- 비지터

## 2.5 REST API

가장 대중적으로 많이 사용되는 애플리케이션 인터페이스

이 인터페이스를 통해 클라이언트는 서버에 접근하고 자원을 조작할 수 있음

### 2.5.1 REST란?

REST (Representational State Transfer): 월드 와이드 웹 (WWW)와 같은 분산 하이퍼 미디어 시스템 아키텍처의 한 형식

주고받는 자원 (Resource)에 이름을 규정하고 URI에 명시헤 HTTP 메서드 (GET, POST, PUT, DELETE)를 통해 해당 자원의 상태를 주고받는 것을 의미

### 2.5.2 REST API란?

API (Application Programming Interface)의 약자로, 애플리케이션에서 제공하는 인터페이스를 의미

API를 통해 서버 또는 프로그램 사이를 연결할 수 있음

즉, REST API는 REST 아키텍처를 따르는 시스템/ 애플리케이션 인터페이스라고 볼 수 있음

REST 아키텍처를 구현하는 웹 서비스를 ‘RESTful하다’라고 표현

### 2.5.3 REST의 특징

- 유니폼 인터페이스 (일관된 인터페이스)
    - REST 서버는 HTTp 표준 전송 규약을 따르기 때문에 어떤 프로그래밍 언어롤 만들어졌냐와 상관없이 플랫폼 및 기술에 종속되지 않고, 플랫폼, 기술 등과 호환해 사용할 수 있다는 것을 의미
- 무상태성
    - REST는 ‘무상태성(stateless)’라는 특징 가짐
    - 서버는 클라이언트가 보낸 요청에 대해 세션이나 쿠키 정보를 별도로 보관하지 X
    - ⇒ 서버가 불필요한 정보를 관리 하지않아 비즈니스 로직의 자유도가 높고 설계가 단순
- 캐시 가능성
    - REST 서버는 네트워크 사의 여러계층으로 구성 될 수 있음 (Layered System)
    - 그러나 서버의 복잡도와 관계 없이 클라이언트는 서버와 연결되는 포인트만 알면 됨
- 클라이언트-서버 아키텍처
    - REST 서버는 API를 제공하고 클라이언트는 사용자 정보를 관리하는 구조로 분리해 설계, 이 구성을 서로에 대한 의존성 낮추는 기능

### 2.5.4 REST의 URI 설계

**URI 규칙**

- URI의 마지막에는 ‘/’를 포함하지 않음
- 언더바 사용 X, 대신 하이픈 (-) 이용
- URL에는 행위(동사) 가 아니라 결과(명사)를 포함
- URI는 소문자로 작성
- 파일의 확장자는 URI에 포함하지 않음 (Accept 헤더 사용)
